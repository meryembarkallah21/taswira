"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-sketch-canvas";
exports.ids = ["vendor-chunks/react-sketch-canvas"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-sketch-canvas/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/react-sketch-canvas/dist/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-sketch-canvas.cjs.development.js */ \"(ssr)/./node_modules/react-sketch-canvas/dist/react-sketch-canvas.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2tldGNoLWNhbnZhcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDWTs7QUFFWixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsNEtBQW9FO0FBQ3RFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29udmV4LXJlcGxpY2F0ZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1za2V0Y2gtY2FudmFzL2Rpc3QvaW5kZXguanM/N2UyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbid1c2Ugc3RyaWN0J1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhY3Qtc2tldGNoLWNhbnZhcy5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWN0LXNrZXRjaC1jYW52YXMuY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-sketch-canvas/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-sketch-canvas/dist/react-sketch-canvas.cjs.development.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/react-sketch-canvas/dist/react-sketch-canvas.cjs.development.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return n;\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar runtime = {exports: {}};\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (module) {\nvar runtime = (function (exports) {\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined$1; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined$1) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined$1;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined$1;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined$1;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined$1, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined$1;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined$1;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined$1;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined$1;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports \n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n}(runtime));\n\nvar _regeneratorRuntime = runtime.exports;\n\n/**\r\n * Generate SVG Path tag from the given points\r\n */\n\nvar SvgPath = function SvgPath(_ref) {\n  var paths = _ref.paths,\n      id = _ref.id,\n      strokeWidth = _ref.strokeWidth,\n      strokeColor = _ref.strokeColor,\n      _ref$command = _ref.command,\n      command = _ref$command === void 0 ? bezierCommand : _ref$command;\n\n  if (paths.length === 1) {\n    var _paths$ = paths[0],\n        x = _paths$.x,\n        y = _paths$.y;\n    var radius = strokeWidth / 2;\n    return React__namespace.createElement(\"circle\", {\n      key: id,\n      id: id,\n      cx: x,\n      cy: y,\n      r: radius,\n      stroke: strokeColor,\n      fill: strokeColor\n    });\n  }\n\n  var d = paths.reduce(function (acc, point, i, a) {\n    return i === 0 ? \"M \" + point.x + \",\" + point.y : acc + \" \" + command(point, i, a);\n  }, '');\n  return React__namespace.createElement(\"path\", {\n    key: id,\n    id: id,\n    d: d,\n    fill: \"none\",\n    strokeLinecap: \"round\",\n    stroke: strokeColor,\n    strokeWidth: strokeWidth\n  });\n};\nvar line = function line(pointA, pointB) {\n  var lengthX = pointB.x - pointA.x;\n  var lengthY = pointB.y - pointA.y;\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n\nvar controlPoint = function controlPoint(controlPoints) {\n  var current = controlPoints.current,\n      next = controlPoints.next,\n      previous = controlPoints.previous,\n      reverse = controlPoints.reverse;\n  var p = previous || current;\n  var n = next || current;\n  var smoothing = 0.2;\n  var o = line(p, n);\n  var angle = o.angle + (reverse ? Math.PI : 0);\n  var length = o.length * smoothing;\n  var x = current.x + Math.cos(angle) * length;\n  var y = current.y + Math.sin(angle) * length;\n  return [x, y];\n};\n\nvar bezierCommand = function bezierCommand(point, i, a) {\n  var cpsX = null;\n  var cpsY = null;\n\n  switch (i) {\n    case 0:\n      var _controlPoint = controlPoint({\n        current: point\n      });\n\n      cpsX = _controlPoint[0];\n      cpsY = _controlPoint[1];\n      break;\n\n    case 1:\n      var _controlPoint2 = controlPoint({\n        current: a[i - 1],\n        next: point\n      });\n\n      cpsX = _controlPoint2[0];\n      cpsY = _controlPoint2[1];\n      break;\n\n    default:\n      var _controlPoint3 = controlPoint({\n        current: a[i - 1],\n        previous: a[i - 2],\n        next: point\n      });\n\n      cpsX = _controlPoint3[0];\n      cpsY = _controlPoint3[1];\n      break;\n  }\n\n  var _controlPoint4 = controlPoint({\n    current: point,\n    previous: a[i - 1],\n    next: a[i + 1],\n    reverse: true\n  }),\n      cpeX = _controlPoint4[0],\n      cpeY = _controlPoint4[1];\n\n  return \"C \" + cpsX + \",\" + cpsY + \" \" + cpeX + \",\" + cpeY + \" \" + point.x + \", \" + point.y;\n};\n\nvar Paths = function Paths(_ref2) {\n  var id = _ref2.id,\n      paths = _ref2.paths;\n  return React__namespace.createElement(React__namespace.Fragment, null, paths.map(function (path, index) {\n    return React__namespace.createElement(SvgPath, {\n      key: id + \"__\" + index,\n      paths: path.paths,\n      id: id + \"__\" + index,\n      strokeWidth: path.strokeWidth,\n      strokeColor: path.strokeColor,\n      command: bezierCommand\n    });\n  }));\n};\n\nvar loadImage = function loadImage(url) {\n  return new Promise(function (resolve, reject) {\n    var img = new Image();\n    img.addEventListener('load', function () {\n      if (img.width > 0) {\n        resolve(img);\n      }\n\n      reject('Image not found');\n    });\n    img.addEventListener('error', function (err) {\n      return reject(err);\n    });\n    img.src = url;\n    img.setAttribute('crossorigin', 'anonymous');\n  });\n};\n\nfunction getCanvasWithViewBox(canvas) {\n  var _canvas$firstChild;\n\n  var svgCanvas = (_canvas$firstChild = canvas.firstChild) == null ? void 0 : _canvas$firstChild.cloneNode(true);\n  var width = canvas.offsetWidth;\n  var height = canvas.offsetHeight;\n  svgCanvas.setAttribute('viewBox', \"0 0 \" + width + \" \" + height);\n  svgCanvas.setAttribute('width', width.toString());\n  svgCanvas.setAttribute('height', height.toString());\n  return {\n    svgCanvas: svgCanvas,\n    width: width,\n    height: height\n  };\n}\n\nvar Canvas = /*#__PURE__*/React__namespace.forwardRef(function (props, ref) {\n  var paths = props.paths,\n      isDrawing = props.isDrawing,\n      onPointerDown = props.onPointerDown,\n      onPointerMove = props.onPointerMove,\n      onPointerUp = props.onPointerUp,\n      _props$id = props.id,\n      id = _props$id === void 0 ? 'react-sketch-canvas' : _props$id,\n      _props$width = props.width,\n      width = _props$width === void 0 ? '100%' : _props$width,\n      _props$height = props.height,\n      height = _props$height === void 0 ? '100%' : _props$height,\n      _props$className = props.className,\n      className = _props$className === void 0 ? 'react-sketch-canvas' : _props$className,\n      _props$canvasColor = props.canvasColor,\n      canvasColor = _props$canvasColor === void 0 ? 'red' : _props$canvasColor,\n      _props$backgroundImag = props.backgroundImage,\n      backgroundImage = _props$backgroundImag === void 0 ? '' : _props$backgroundImag,\n      _props$exportWithBack = props.exportWithBackgroundImage,\n      exportWithBackgroundImage = _props$exportWithBack === void 0 ? false : _props$exportWithBack,\n      _props$preserveBackgr = props.preserveBackgroundImageAspectRatio,\n      preserveBackgroundImageAspectRatio = _props$preserveBackgr === void 0 ? 'none' : _props$preserveBackgr,\n      _props$allowOnlyPoint = props.allowOnlyPointerType,\n      allowOnlyPointerType = _props$allowOnlyPoint === void 0 ? 'all' : _props$allowOnlyPoint,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {\n    border: '0.0625rem solid #9c9c9c',\n    borderRadius: '0.25rem'\n  } : _props$style,\n      _props$svgStyle = props.svgStyle,\n      svgStyle = _props$svgStyle === void 0 ? {} : _props$svgStyle;\n  var canvasRef = React__namespace.useRef(null); // Converts mouse coordinates to relative coordinate based on the absolute position of svg\n\n  var getCoordinates = function getCoordinates(pointerEvent) {\n    var _canvasRef$current, _window$scrollX, _window$scrollY;\n\n    var boundingArea = (_canvasRef$current = canvasRef.current) == null ? void 0 : _canvasRef$current.getBoundingClientRect();\n    var scrollLeft = (_window$scrollX = window.scrollX) != null ? _window$scrollX : 0;\n    var scrollTop = (_window$scrollY = window.scrollY) != null ? _window$scrollY : 0;\n\n    if (!boundingArea) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n\n    var point = {\n      x: pointerEvent.pageX - boundingArea.left - scrollLeft,\n      y: pointerEvent.pageY - boundingArea.top - scrollTop\n    };\n    return point;\n  };\n  /* Mouse Handlers - Mouse down, move and up */\n\n\n  var handlePointerDown = function handlePointerDown(event) {\n    // Allow only chosen pointer type\n    if (allowOnlyPointerType !== 'all' && event.pointerType !== allowOnlyPointerType) {\n      return;\n    }\n\n    if (event.pointerType === 'mouse' && event.button !== 0) return;\n    var point = getCoordinates(event);\n    onPointerDown(point);\n  };\n\n  var handlePointerMove = function handlePointerMove(event) {\n    if (!isDrawing) return; // Allow only chosen pointer type\n\n    if (allowOnlyPointerType !== 'all' && event.pointerType !== allowOnlyPointerType) {\n      return;\n    }\n\n    var point = getCoordinates(event);\n    onPointerMove(point);\n  };\n\n  var handlePointerUp = function handlePointerUp(event) {\n    if (event.pointerType === 'mouse' && event.button !== 0) return; // Allow only chosen pointer type\n\n    if (allowOnlyPointerType !== 'all' && event.pointerType !== allowOnlyPointerType) {\n      return;\n    }\n\n    onPointerUp();\n  };\n  /* Mouse Handlers ends */\n\n\n  React__namespace.useImperativeHandle(ref, function () {\n    return {\n      exportImage: function exportImage(imageType) {\n        return new Promise( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n            var canvas, _getCanvasWithViewBox, svgCanvas, _width, _height, canvasSketch, loadImagePromises, img;\n\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.prev = 0;\n                    canvas = canvasRef.current;\n\n                    if (canvas) {\n                      _context.next = 4;\n                      break;\n                    }\n\n                    throw Error('Canvas not rendered yet');\n\n                  case 4:\n                    _getCanvasWithViewBox = getCanvasWithViewBox(canvas), svgCanvas = _getCanvasWithViewBox.svgCanvas, _width = _getCanvasWithViewBox.width, _height = _getCanvasWithViewBox.height;\n                    canvasSketch = \"data:image/svg+xml;base64,\" + btoa(svgCanvas.outerHTML);\n                    _context.next = 8;\n                    return loadImage(canvasSketch);\n\n                  case 8:\n                    _context.t0 = _context.sent;\n                    loadImagePromises = [_context.t0];\n\n                    if (!exportWithBackgroundImage) {\n                      _context.next = 21;\n                      break;\n                    }\n\n                    _context.prev = 11;\n                    _context.next = 14;\n                    return loadImage(backgroundImage);\n\n                  case 14:\n                    img = _context.sent;\n                    loadImagePromises.push(img);\n                    _context.next = 21;\n                    break;\n\n                  case 18:\n                    _context.prev = 18;\n                    _context.t1 = _context[\"catch\"](11);\n                    console.warn('exportWithBackgroundImage props is set without a valid background image URL. This option is ignored');\n\n                  case 21:\n                    Promise.all(loadImagePromises).then(function (images) {\n                      var renderCanvas = document.createElement('canvas');\n                      renderCanvas.setAttribute('width', _width.toString());\n                      renderCanvas.setAttribute('height', _height.toString());\n                      var context = renderCanvas.getContext('2d');\n\n                      if (!context) {\n                        throw Error('Canvas not rendered yet');\n                      }\n\n                      images.reverse().forEach(function (image) {\n                        context.drawImage(image, 0, 0);\n                      });\n                      resolve(renderCanvas.toDataURL(\"image/\" + imageType));\n                    })[\"catch\"](function (e) {\n                      throw e;\n                    });\n                    _context.next = 27;\n                    break;\n\n                  case 24:\n                    _context.prev = 24;\n                    _context.t2 = _context[\"catch\"](0);\n                    reject(_context.t2);\n\n                  case 27:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, null, [[0, 24], [11, 18]]);\n          }));\n\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      },\n      exportSvg: function exportSvg() {\n        return new Promise(function (resolve, reject) {\n          try {\n            var _canvasRef$current2;\n\n            var canvas = (_canvasRef$current2 = canvasRef.current) != null ? _canvasRef$current2 : null;\n\n            if (canvas !== null) {\n              var _svgCanvas$querySelec, _svgCanvas$querySelec2;\n\n              var _getCanvasWithViewBox2 = getCanvasWithViewBox(canvas),\n                  svgCanvas = _getCanvasWithViewBox2.svgCanvas;\n\n              if (exportWithBackgroundImage) {\n                resolve(svgCanvas.outerHTML);\n                return;\n              }\n\n              (_svgCanvas$querySelec = svgCanvas.querySelector(\"#\" + id + \"__background\")) == null ? void 0 : _svgCanvas$querySelec.remove();\n              (_svgCanvas$querySelec2 = svgCanvas.querySelector(\"#\" + id + \"__canvas-background\")) == null ? void 0 : _svgCanvas$querySelec2.setAttribute('fill', canvasColor);\n              resolve(svgCanvas.outerHTML);\n            }\n\n            reject(new Error('Canvas not loaded'));\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }\n    };\n  });\n  /* Add event listener to Mouse up and Touch up to\r\n  release drawing even when point goes out of canvas */\n\n  React__namespace.useEffect(function () {\n    document.addEventListener('pointerup', handlePointerUp);\n    return function () {\n      document.removeEventListener('pointerup', handlePointerUp);\n    };\n  }, [handlePointerUp]);\n  var eraserPaths = paths.filter(function (path) {\n    return !path.drawMode;\n  });\n  var currentGroup = 0;\n  var pathGroups = paths.reduce(function (arrayGroup, path) {\n    if (!path.drawMode) {\n      currentGroup += 1;\n      return arrayGroup;\n    }\n\n    if (arrayGroup[currentGroup] === undefined) {\n      arrayGroup[currentGroup] = [];\n    }\n\n    arrayGroup[currentGroup].push(path);\n    return arrayGroup;\n  }, [[]]);\n  return React__namespace.createElement(\"div\", {\n    role: \"presentation\",\n    ref: canvasRef,\n    className: className,\n    style: _extends({\n      touchAction: 'none',\n      width: width,\n      height: height\n    }, style),\n    \"touch-action\": \"none\",\n    onPointerDown: handlePointerDown,\n    onPointerMove: handlePointerMove,\n    onPointerUp: handlePointerUp\n  }, React__namespace.createElement(\"svg\", {\n    version: \"1.1\",\n    baseProfile: \"full\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n    style: _extends({\n      width: '100%',\n      height: '100%'\n    }, svgStyle),\n    id: id\n  }, React__namespace.createElement(\"g\", {\n    id: id + \"__eraser-stroke-group\",\n    display: \"none\"\n  }, React__namespace.createElement(\"rect\", {\n    id: id + \"__mask-background\",\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    fill: \"white\"\n  }), eraserPaths.map(function (eraserPath, i) {\n    return React__namespace.createElement(SvgPath, {\n      key: id + \"__eraser-\" + i,\n      id: id + \"__eraser-\" + i,\n      paths: eraserPath.paths,\n      strokeColor: \"#000000\",\n      strokeWidth: eraserPath.strokeWidth\n    });\n  })), React__namespace.createElement(\"defs\", null, backgroundImage && React__namespace.createElement(\"pattern\", {\n    id: id + \"__background\",\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    patternUnits: \"userSpaceOnUse\"\n  }, React__namespace.createElement(\"image\", {\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    xlinkHref: backgroundImage,\n    preserveAspectRatio: preserveBackgroundImageAspectRatio\n  })), eraserPaths.map(function (_, i) {\n    return React__namespace.createElement(\"mask\", {\n      id: id + \"__eraser-mask-\" + i,\n      key: id + \"__eraser-mask-\" + i,\n      maskUnits: \"userSpaceOnUse\"\n    }, React__namespace.createElement(\"use\", {\n      href: \"#\" + id + \"__mask-background\"\n    }), Array.from({\n      length: eraserPaths.length - i\n    }, function (_, j) {\n      return j + i;\n    }).map(function (k) {\n      return React__namespace.createElement(\"use\", {\n        key: k.toString(),\n        href: \"#\" + id + \"__eraser-\" + k.toString()\n      });\n    }));\n  })), React__namespace.createElement(\"g\", {\n    id: id + \"__canvas-background-group\"\n  }, React__namespace.createElement(\"rect\", {\n    id: id + \"__canvas-background\",\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    fill: backgroundImage ? \"url(#\" + id + \"__background)\" : canvasColor\n  })), pathGroups.map(function (pathGroup, i) {\n    return React__namespace.createElement(\"g\", {\n      id: id + \"__stroke-group-\" + i,\n      key: id + \"__stroke-group-\" + i,\n      mask: \"url(#\" + id + \"__eraser-mask-\" + i + \")\"\n    }, React__namespace.createElement(Paths, {\n      id: id,\n      paths: pathGroup\n    }));\n  })));\n});\n\nvar ReactSketchCanvas = /*#__PURE__*/React__namespace.forwardRef(function (props, ref) {\n  var _props$id = props.id,\n      id = _props$id === void 0 ? 'react-sketch-canvas' : _props$id,\n      _props$width = props.width,\n      width = _props$width === void 0 ? '100%' : _props$width,\n      _props$height = props.height,\n      height = _props$height === void 0 ? '100%' : _props$height,\n      _props$className = props.className,\n      className = _props$className === void 0 ? '' : _props$className,\n      _props$canvasColor = props.canvasColor,\n      canvasColor = _props$canvasColor === void 0 ? 'white' : _props$canvasColor,\n      _props$strokeColor = props.strokeColor,\n      strokeColor = _props$strokeColor === void 0 ? 'red' : _props$strokeColor,\n      _props$backgroundImag = props.backgroundImage,\n      backgroundImage = _props$backgroundImag === void 0 ? '' : _props$backgroundImag,\n      _props$exportWithBack = props.exportWithBackgroundImage,\n      exportWithBackgroundImage = _props$exportWithBack === void 0 ? false : _props$exportWithBack,\n      _props$preserveBackgr = props.preserveBackgroundImageAspectRatio,\n      preserveBackgroundImageAspectRatio = _props$preserveBackgr === void 0 ? 'none' : _props$preserveBackgr,\n      _props$strokeWidth = props.strokeWidth,\n      strokeWidth = _props$strokeWidth === void 0 ? 4 : _props$strokeWidth,\n      _props$eraserWidth = props.eraserWidth,\n      eraserWidth = _props$eraserWidth === void 0 ? 8 : _props$eraserWidth,\n      _props$allowOnlyPoint = props.allowOnlyPointerType,\n      allowOnlyPointerType = _props$allowOnlyPoint === void 0 ? 'all' : _props$allowOnlyPoint,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {\n    border: '0.0625rem solid #9c9c9c',\n    borderRadius: '0.25rem'\n  } : _props$style,\n      _props$svgStyle = props.svgStyle,\n      svgStyle = _props$svgStyle === void 0 ? {} : _props$svgStyle,\n      _props$onChange = props.onChange,\n      onChange = _props$onChange === void 0 ? function (_paths) {} : _props$onChange,\n      _props$onStroke = props.onStroke,\n      onStroke = _props$onStroke === void 0 ? function (_path, _isEraser) {} : _props$onStroke,\n      _props$withTimestamp = props.withTimestamp,\n      withTimestamp = _props$withTimestamp === void 0 ? false : _props$withTimestamp;\n  var svgCanvas = React__namespace.createRef();\n\n  var _React$useState = React__namespace.useState(true),\n      drawMode = _React$useState[0],\n      setDrawMode = _React$useState[1];\n\n  var _React$useState2 = React__namespace.useState(false),\n      isDrawing = _React$useState2[0],\n      setIsDrawing = _React$useState2[1];\n\n  var _React$useState3 = React__namespace.useState([]),\n      resetStack = _React$useState3[0],\n      setResetStack = _React$useState3[1];\n\n  var _React$useState4 = React__namespace.useState([]),\n      undoStack = _React$useState4[0],\n      setUndoStack = _React$useState4[1];\n\n  var _React$useState5 = React__namespace.useState([]),\n      currentPaths = _React$useState5[0],\n      setCurrentPaths = _React$useState5[1];\n\n  var liftStrokeUp = React__namespace.useCallback(function () {\n    var _currentPaths$slice$, _currentPaths$slice;\n\n    var lastStroke = (_currentPaths$slice$ = (_currentPaths$slice = currentPaths.slice(-1)) == null ? void 0 : _currentPaths$slice[0]) != null ? _currentPaths$slice$ : null;\n\n    if (lastStroke === null) {\n      console.warn('No stroke found!');\n      return;\n    }\n\n    onStroke(lastStroke, !lastStroke.drawMode);\n  }, [isDrawing]);\n  React__namespace.useEffect(function () {\n    liftStrokeUp();\n  }, [isDrawing]);\n  React__namespace.useEffect(function () {\n    onChange(currentPaths);\n  }, [currentPaths]);\n  React__namespace.useImperativeHandle(ref, function () {\n    return {\n      eraseMode: function eraseMode(erase) {\n        setDrawMode(!erase);\n      },\n      clearCanvas: function clearCanvas() {\n        setResetStack([].concat(currentPaths));\n        setCurrentPaths([]);\n      },\n      undo: function undo() {\n        // If there was a last reset then\n        if (resetStack.length !== 0) {\n          setCurrentPaths([].concat(resetStack));\n          setResetStack([]);\n          return;\n        }\n\n        setUndoStack(function (undoStack) {\n          return [].concat(undoStack, currentPaths.slice(-1));\n        });\n        setCurrentPaths(function (currentPaths) {\n          return currentPaths.slice(0, -1);\n        });\n      },\n      redo: function redo() {\n        // Nothing to Redo\n        if (undoStack.length === 0) return;\n        setCurrentPaths(function (currentPaths) {\n          return [].concat(currentPaths, undoStack.slice(-1));\n        });\n        setUndoStack(function (undoStack) {\n          return undoStack.slice(0, -1);\n        });\n      },\n      exportImage: function exportImage(imageType) {\n        var _svgCanvas$current;\n\n        var exportImage = (_svgCanvas$current = svgCanvas.current) == null ? void 0 : _svgCanvas$current.exportImage;\n\n        if (!exportImage) {\n          throw Error('Export function called before canvas loaded');\n        } else {\n          return exportImage(imageType);\n        }\n      },\n      exportSvg: function exportSvg() {\n        return new Promise(function (resolve, reject) {\n          var _svgCanvas$current2;\n\n          var exportSvg = (_svgCanvas$current2 = svgCanvas.current) == null ? void 0 : _svgCanvas$current2.exportSvg;\n\n          if (!exportSvg) {\n            reject(Error('Export function called before canvas loaded'));\n          } else {\n            exportSvg().then(function (data) {\n              resolve(data);\n            })[\"catch\"](function (e) {\n              reject(e);\n            });\n          }\n        });\n      },\n      exportPaths: function exportPaths() {\n        return new Promise(function (resolve, reject) {\n          try {\n            resolve(currentPaths);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n      loadPaths: function loadPaths(paths) {\n        setCurrentPaths(function (currentPaths) {\n          return [].concat(currentPaths, paths);\n        });\n      },\n      getSketchingTime: function getSketchingTime() {\n        return new Promise(function (resolve, reject) {\n          if (!withTimestamp) {\n            reject(new Error(\"Set 'withTimestamp' prop to get sketching time\"));\n          }\n\n          try {\n            var sketchingTime = currentPaths.reduce(function (totalSketchingTime, path) {\n              var _path$startTimestamp, _path$endTimestamp;\n\n              var startTimestamp = (_path$startTimestamp = path.startTimestamp) != null ? _path$startTimestamp : 0;\n              var endTimestamp = (_path$endTimestamp = path.endTimestamp) != null ? _path$endTimestamp : 0;\n              return totalSketchingTime + (endTimestamp - startTimestamp);\n            }, 0);\n            resolve(sketchingTime);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n      resetCanvas: function resetCanvas() {\n        setResetStack([]);\n        setUndoStack([]);\n        setCurrentPaths([]);\n      }\n    };\n  });\n\n  var handlePointerDown = function handlePointerDown(point) {\n    setIsDrawing(true);\n    setUndoStack([]);\n    var stroke = {\n      drawMode: drawMode,\n      strokeColor: drawMode ? strokeColor : '#000000',\n      strokeWidth: drawMode ? strokeWidth : eraserWidth,\n      paths: [point]\n    };\n\n    if (withTimestamp) {\n      stroke = _extends({}, stroke, {\n        startTimestamp: Date.now(),\n        endTimestamp: 0\n      });\n    }\n\n    setCurrentPaths(function (currentPaths) {\n      return [].concat(currentPaths, [stroke]);\n    });\n  };\n\n  var handlePointerMove = function handlePointerMove(point) {\n    if (!isDrawing) return;\n    var currentStroke = currentPaths.slice(-1)[0];\n\n    var updatedStroke = _extends({}, currentStroke, {\n      paths: [].concat(currentStroke.paths, [point])\n    });\n\n    setCurrentPaths(function (currentPaths) {\n      return [].concat(currentPaths.slice(0, -1), [updatedStroke]);\n    });\n  };\n\n  var handlePointerUp = function handlePointerUp() {\n    var _currentPaths$slice$2, _currentPaths$slice2;\n\n    if (!isDrawing) {\n      return;\n    }\n\n    setIsDrawing(false);\n\n    if (!withTimestamp) {\n      return;\n    }\n\n    var currentStroke = (_currentPaths$slice$2 = (_currentPaths$slice2 = currentPaths.slice(-1)) == null ? void 0 : _currentPaths$slice2[0]) != null ? _currentPaths$slice$2 : null;\n\n    if (currentStroke === null) {\n      return;\n    }\n\n    var updatedStroke = _extends({}, currentStroke, {\n      endTimestamp: Date.now()\n    });\n\n    setCurrentPaths(function (currentPaths) {\n      return [].concat(currentPaths.slice(0, -1), [updatedStroke]);\n    });\n  };\n\n  return React__namespace.createElement(Canvas, {\n    ref: svgCanvas,\n    id: id,\n    width: width,\n    height: height,\n    className: className,\n    canvasColor: canvasColor,\n    backgroundImage: backgroundImage,\n    exportWithBackgroundImage: exportWithBackgroundImage,\n    preserveBackgroundImageAspectRatio: preserveBackgroundImageAspectRatio,\n    allowOnlyPointerType: allowOnlyPointerType,\n    style: style,\n    svgStyle: svgStyle,\n    paths: currentPaths,\n    isDrawing: isDrawing,\n    onPointerDown: handlePointerDown,\n    onPointerMove: handlePointerMove,\n    onPointerUp: handlePointerUp\n  });\n});\n\nexports.Canvas = Canvas;\nexports.ReactSketchCanvas = ReactSketchCanvas;\n//# sourceMappingURL=react-sketch-canvas.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2tldGNoLWNhbnZhcy9kaXN0L3JlYWN0LXNrZXRjaC1jYW52YXMuY2pzLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpREFBaUQ7QUFDakQsaURBQWlEOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQsY0FBYztBQUNkLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbnZleC1yZXBsaWNhdGUvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2tldGNoLWNhbnZhcy9kaXN0L3JlYWN0LXNrZXRjaC1jYW52YXMuY2pzLmRldmVsb3BtZW50LmpzPzhmZjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBuO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgcnVudGltZSA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkJDE7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkJDEpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCQxLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCQxO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkJDE7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIG1vZHVsZS5leHBvcnRzIFxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCBpbiBtb2Rlcm4gZW5naW5lc1xuICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxufShydW50aW1lKSk7XG5cbnZhciBfcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZS5leHBvcnRzO1xuXG4vKipcclxuICogR2VuZXJhdGUgU1ZHIFBhdGggdGFnIGZyb20gdGhlIGdpdmVuIHBvaW50c1xyXG4gKi9cblxudmFyIFN2Z1BhdGggPSBmdW5jdGlvbiBTdmdQYXRoKF9yZWYpIHtcbiAgdmFyIHBhdGhzID0gX3JlZi5wYXRocyxcbiAgICAgIGlkID0gX3JlZi5pZCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZUNvbG9yID0gX3JlZi5zdHJva2VDb2xvcixcbiAgICAgIF9yZWYkY29tbWFuZCA9IF9yZWYuY29tbWFuZCxcbiAgICAgIGNvbW1hbmQgPSBfcmVmJGNvbW1hbmQgPT09IHZvaWQgMCA/IGJlemllckNvbW1hbmQgOiBfcmVmJGNvbW1hbmQ7XG5cbiAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBfcGF0aHMkID0gcGF0aHNbMF0sXG4gICAgICAgIHggPSBfcGF0aHMkLngsXG4gICAgICAgIHkgPSBfcGF0aHMkLnk7XG4gICAgdmFyIHJhZGl1cyA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICAgIGtleTogaWQsXG4gICAgICBpZDogaWQsXG4gICAgICBjeDogeCxcbiAgICAgIGN5OiB5LFxuICAgICAgcjogcmFkaXVzLFxuICAgICAgc3Ryb2tlOiBzdHJva2VDb2xvcixcbiAgICAgIGZpbGw6IHN0cm9rZUNvbG9yXG4gICAgfSk7XG4gIH1cblxuICB2YXIgZCA9IHBhdGhzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwb2ludCwgaSwgYSkge1xuICAgIHJldHVybiBpID09PSAwID8gXCJNIFwiICsgcG9pbnQueCArIFwiLFwiICsgcG9pbnQueSA6IGFjYyArIFwiIFwiICsgY29tbWFuZChwb2ludCwgaSwgYSk7XG4gIH0sICcnKTtcbiAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGtleTogaWQsXG4gICAgaWQ6IGlkLFxuICAgIGQ6IGQsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZTogc3Ryb2tlQ29sb3IsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoXG4gIH0pO1xufTtcbnZhciBsaW5lID0gZnVuY3Rpb24gbGluZShwb2ludEEsIHBvaW50Qikge1xuICB2YXIgbGVuZ3RoWCA9IHBvaW50Qi54IC0gcG9pbnRBLng7XG4gIHZhciBsZW5ndGhZID0gcG9pbnRCLnkgLSBwb2ludEEueTtcbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IE1hdGguc3FydChNYXRoLnBvdyhsZW5ndGhYLCAyKSArIE1hdGgucG93KGxlbmd0aFksIDIpKSxcbiAgICBhbmdsZTogTWF0aC5hdGFuMihsZW5ndGhZLCBsZW5ndGhYKVxuICB9O1xufTtcblxudmFyIGNvbnRyb2xQb2ludCA9IGZ1bmN0aW9uIGNvbnRyb2xQb2ludChjb250cm9sUG9pbnRzKSB7XG4gIHZhciBjdXJyZW50ID0gY29udHJvbFBvaW50cy5jdXJyZW50LFxuICAgICAgbmV4dCA9IGNvbnRyb2xQb2ludHMubmV4dCxcbiAgICAgIHByZXZpb3VzID0gY29udHJvbFBvaW50cy5wcmV2aW91cyxcbiAgICAgIHJldmVyc2UgPSBjb250cm9sUG9pbnRzLnJldmVyc2U7XG4gIHZhciBwID0gcHJldmlvdXMgfHwgY3VycmVudDtcbiAgdmFyIG4gPSBuZXh0IHx8IGN1cnJlbnQ7XG4gIHZhciBzbW9vdGhpbmcgPSAwLjI7XG4gIHZhciBvID0gbGluZShwLCBuKTtcbiAgdmFyIGFuZ2xlID0gby5hbmdsZSArIChyZXZlcnNlID8gTWF0aC5QSSA6IDApO1xuICB2YXIgbGVuZ3RoID0gby5sZW5ndGggKiBzbW9vdGhpbmc7XG4gIHZhciB4ID0gY3VycmVudC54ICsgTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoO1xuICB2YXIgeSA9IGN1cnJlbnQueSArIE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aDtcbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbnZhciBiZXppZXJDb21tYW5kID0gZnVuY3Rpb24gYmV6aWVyQ29tbWFuZChwb2ludCwgaSwgYSkge1xuICB2YXIgY3BzWCA9IG51bGw7XG4gIHZhciBjcHNZID0gbnVsbDtcblxuICBzd2l0Y2ggKGkpIHtcbiAgICBjYXNlIDA6XG4gICAgICB2YXIgX2NvbnRyb2xQb2ludCA9IGNvbnRyb2xQb2ludCh7XG4gICAgICAgIGN1cnJlbnQ6IHBvaW50XG4gICAgICB9KTtcblxuICAgICAgY3BzWCA9IF9jb250cm9sUG9pbnRbMF07XG4gICAgICBjcHNZID0gX2NvbnRyb2xQb2ludFsxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgdmFyIF9jb250cm9sUG9pbnQyID0gY29udHJvbFBvaW50KHtcbiAgICAgICAgY3VycmVudDogYVtpIC0gMV0sXG4gICAgICAgIG5leHQ6IHBvaW50XG4gICAgICB9KTtcblxuICAgICAgY3BzWCA9IF9jb250cm9sUG9pbnQyWzBdO1xuICAgICAgY3BzWSA9IF9jb250cm9sUG9pbnQyWzFdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIF9jb250cm9sUG9pbnQzID0gY29udHJvbFBvaW50KHtcbiAgICAgICAgY3VycmVudDogYVtpIC0gMV0sXG4gICAgICAgIHByZXZpb3VzOiBhW2kgLSAyXSxcbiAgICAgICAgbmV4dDogcG9pbnRcbiAgICAgIH0pO1xuXG4gICAgICBjcHNYID0gX2NvbnRyb2xQb2ludDNbMF07XG4gICAgICBjcHNZID0gX2NvbnRyb2xQb2ludDNbMV07XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBfY29udHJvbFBvaW50NCA9IGNvbnRyb2xQb2ludCh7XG4gICAgY3VycmVudDogcG9pbnQsXG4gICAgcHJldmlvdXM6IGFbaSAtIDFdLFxuICAgIG5leHQ6IGFbaSArIDFdLFxuICAgIHJldmVyc2U6IHRydWVcbiAgfSksXG4gICAgICBjcGVYID0gX2NvbnRyb2xQb2ludDRbMF0sXG4gICAgICBjcGVZID0gX2NvbnRyb2xQb2ludDRbMV07XG5cbiAgcmV0dXJuIFwiQyBcIiArIGNwc1ggKyBcIixcIiArIGNwc1kgKyBcIiBcIiArIGNwZVggKyBcIixcIiArIGNwZVkgKyBcIiBcIiArIHBvaW50LnggKyBcIiwgXCIgKyBwb2ludC55O1xufTtcblxudmFyIFBhdGhzID0gZnVuY3Rpb24gUGF0aHMoX3JlZjIpIHtcbiAgdmFyIGlkID0gX3JlZjIuaWQsXG4gICAgICBwYXRocyA9IF9yZWYyLnBhdGhzO1xuICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCwgaW5kZXgpIHtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFN2Z1BhdGgsIHtcbiAgICAgIGtleTogaWQgKyBcIl9fXCIgKyBpbmRleCxcbiAgICAgIHBhdGhzOiBwYXRoLnBhdGhzLFxuICAgICAgaWQ6IGlkICsgXCJfX1wiICsgaW5kZXgsXG4gICAgICBzdHJva2VXaWR0aDogcGF0aC5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZUNvbG9yOiBwYXRoLnN0cm9rZUNvbG9yLFxuICAgICAgY29tbWFuZDogYmV6aWVyQ29tbWFuZFxuICAgIH0pO1xuICB9KSk7XG59O1xuXG52YXIgbG9hZEltYWdlID0gZnVuY3Rpb24gbG9hZEltYWdlKHVybCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpbWcud2lkdGggPiAwKSB7XG4gICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KCdJbWFnZSBub3QgZm91bmQnKTtcbiAgICB9KTtcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfSk7XG4gICAgaW1nLnNyYyA9IHVybDtcbiAgICBpbWcuc2V0QXR0cmlidXRlKCdjcm9zc29yaWdpbicsICdhbm9ueW1vdXMnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBnZXRDYW52YXNXaXRoVmlld0JveChjYW52YXMpIHtcbiAgdmFyIF9jYW52YXMkZmlyc3RDaGlsZDtcblxuICB2YXIgc3ZnQ2FudmFzID0gKF9jYW52YXMkZmlyc3RDaGlsZCA9IGNhbnZhcy5maXJzdENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2NhbnZhcyRmaXJzdENoaWxkLmNsb25lTm9kZSh0cnVlKTtcbiAgdmFyIHdpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodDtcbiAgc3ZnQ2FudmFzLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFwiMCAwIFwiICsgd2lkdGggKyBcIiBcIiArIGhlaWdodCk7XG4gIHN2Z0NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgudG9TdHJpbmcoKSk7XG4gIHN2Z0NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodC50b1N0cmluZygpKTtcbiAgcmV0dXJuIHtcbiAgICBzdmdDYW52YXM6IHN2Z0NhbnZhcyxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cblxudmFyIENhbnZhcyA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIHBhdGhzID0gcHJvcHMucGF0aHMsXG4gICAgICBpc0RyYXdpbmcgPSBwcm9wcy5pc0RyYXdpbmcsXG4gICAgICBvblBvaW50ZXJEb3duID0gcHJvcHMub25Qb2ludGVyRG93bixcbiAgICAgIG9uUG9pbnRlck1vdmUgPSBwcm9wcy5vblBvaW50ZXJNb3ZlLFxuICAgICAgb25Qb2ludGVyVXAgPSBwcm9wcy5vblBvaW50ZXJVcCxcbiAgICAgIF9wcm9wcyRpZCA9IHByb3BzLmlkLFxuICAgICAgaWQgPSBfcHJvcHMkaWQgPT09IHZvaWQgMCA/ICdyZWFjdC1za2V0Y2gtY2FudmFzJyA6IF9wcm9wcyRpZCxcbiAgICAgIF9wcm9wcyR3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgICAgd2lkdGggPSBfcHJvcHMkd2lkdGggPT09IHZvaWQgMCA/ICcxMDAlJyA6IF9wcm9wcyR3aWR0aCxcbiAgICAgIF9wcm9wcyRoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXG4gICAgICBoZWlnaHQgPSBfcHJvcHMkaGVpZ2h0ID09PSB2b2lkIDAgPyAnMTAwJScgOiBfcHJvcHMkaGVpZ2h0LFxuICAgICAgX3Byb3BzJGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9wcm9wcyRjbGFzc05hbWUgPT09IHZvaWQgMCA/ICdyZWFjdC1za2V0Y2gtY2FudmFzJyA6IF9wcm9wcyRjbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY2FudmFzQ29sb3IgPSBwcm9wcy5jYW52YXNDb2xvcixcbiAgICAgIGNhbnZhc0NvbG9yID0gX3Byb3BzJGNhbnZhc0NvbG9yID09PSB2b2lkIDAgPyAncmVkJyA6IF9wcm9wcyRjYW52YXNDb2xvcixcbiAgICAgIF9wcm9wcyRiYWNrZ3JvdW5kSW1hZyA9IHByb3BzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgIGJhY2tncm91bmRJbWFnZSA9IF9wcm9wcyRiYWNrZ3JvdW5kSW1hZyA9PT0gdm9pZCAwID8gJycgOiBfcHJvcHMkYmFja2dyb3VuZEltYWcsXG4gICAgICBfcHJvcHMkZXhwb3J0V2l0aEJhY2sgPSBwcm9wcy5leHBvcnRXaXRoQmFja2dyb3VuZEltYWdlLFxuICAgICAgZXhwb3J0V2l0aEJhY2tncm91bmRJbWFnZSA9IF9wcm9wcyRleHBvcnRXaXRoQmFjayA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZXhwb3J0V2l0aEJhY2ssXG4gICAgICBfcHJvcHMkcHJlc2VydmVCYWNrZ3IgPSBwcm9wcy5wcmVzZXJ2ZUJhY2tncm91bmRJbWFnZUFzcGVjdFJhdGlvLFxuICAgICAgcHJlc2VydmVCYWNrZ3JvdW5kSW1hZ2VBc3BlY3RSYXRpbyA9IF9wcm9wcyRwcmVzZXJ2ZUJhY2tnciA9PT0gdm9pZCAwID8gJ25vbmUnIDogX3Byb3BzJHByZXNlcnZlQmFja2dyLFxuICAgICAgX3Byb3BzJGFsbG93T25seVBvaW50ID0gcHJvcHMuYWxsb3dPbmx5UG9pbnRlclR5cGUsXG4gICAgICBhbGxvd09ubHlQb2ludGVyVHlwZSA9IF9wcm9wcyRhbGxvd09ubHlQb2ludCA9PT0gdm9pZCAwID8gJ2FsbCcgOiBfcHJvcHMkYWxsb3dPbmx5UG9pbnQsXG4gICAgICBfcHJvcHMkc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIHN0eWxlID0gX3Byb3BzJHN0eWxlID09PSB2b2lkIDAgPyB7XG4gICAgYm9yZGVyOiAnMC4wNjI1cmVtIHNvbGlkICM5YzljOWMnLFxuICAgIGJvcmRlclJhZGl1czogJzAuMjVyZW0nXG4gIH0gOiBfcHJvcHMkc3R5bGUsXG4gICAgICBfcHJvcHMkc3ZnU3R5bGUgPSBwcm9wcy5zdmdTdHlsZSxcbiAgICAgIHN2Z1N0eWxlID0gX3Byb3BzJHN2Z1N0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRzdmdTdHlsZTtcbiAgdmFyIGNhbnZhc1JlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKG51bGwpOyAvLyBDb252ZXJ0cyBtb3VzZSBjb29yZGluYXRlcyB0byByZWxhdGl2ZSBjb29yZGluYXRlIGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBzdmdcblxuICB2YXIgZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyhwb2ludGVyRXZlbnQpIHtcbiAgICB2YXIgX2NhbnZhc1JlZiRjdXJyZW50LCBfd2luZG93JHNjcm9sbFgsIF93aW5kb3ckc2Nyb2xsWTtcblxuICAgIHZhciBib3VuZGluZ0FyZWEgPSAoX2NhbnZhc1JlZiRjdXJyZW50ID0gY2FudmFzUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfY2FudmFzUmVmJGN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHNjcm9sbExlZnQgPSAoX3dpbmRvdyRzY3JvbGxYID0gd2luZG93LnNjcm9sbFgpICE9IG51bGwgPyBfd2luZG93JHNjcm9sbFggOiAwO1xuICAgIHZhciBzY3JvbGxUb3AgPSAoX3dpbmRvdyRzY3JvbGxZID0gd2luZG93LnNjcm9sbFkpICE9IG51bGwgPyBfd2luZG93JHNjcm9sbFkgOiAwO1xuXG4gICAgaWYgKCFib3VuZGluZ0FyZWEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHBvaW50ID0ge1xuICAgICAgeDogcG9pbnRlckV2ZW50LnBhZ2VYIC0gYm91bmRpbmdBcmVhLmxlZnQgLSBzY3JvbGxMZWZ0LFxuICAgICAgeTogcG9pbnRlckV2ZW50LnBhZ2VZIC0gYm91bmRpbmdBcmVhLnRvcCAtIHNjcm9sbFRvcFxuICAgIH07XG4gICAgcmV0dXJuIHBvaW50O1xuICB9O1xuICAvKiBNb3VzZSBIYW5kbGVycyAtIE1vdXNlIGRvd24sIG1vdmUgYW5kIHVwICovXG5cblxuICB2YXIgaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bihldmVudCkge1xuICAgIC8vIEFsbG93IG9ubHkgY2hvc2VuIHBvaW50ZXIgdHlwZVxuICAgIGlmIChhbGxvd09ubHlQb2ludGVyVHlwZSAhPT0gJ2FsbCcgJiYgZXZlbnQucG9pbnRlclR5cGUgIT09IGFsbG93T25seVBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgIHZhciBwb2ludCA9IGdldENvb3JkaW5hdGVzKGV2ZW50KTtcbiAgICBvblBvaW50ZXJEb3duKHBvaW50KTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9pbnRlck1vdmUgPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyTW92ZShldmVudCkge1xuICAgIGlmICghaXNEcmF3aW5nKSByZXR1cm47IC8vIEFsbG93IG9ubHkgY2hvc2VuIHBvaW50ZXIgdHlwZVxuXG4gICAgaWYgKGFsbG93T25seVBvaW50ZXJUeXBlICE9PSAnYWxsJyAmJiBldmVudC5wb2ludGVyVHlwZSAhPT0gYWxsb3dPbmx5UG9pbnRlclR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQgPSBnZXRDb29yZGluYXRlcyhldmVudCk7XG4gICAgb25Qb2ludGVyTW92ZShwb2ludCk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJVcChldmVudCkge1xuICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyAmJiBldmVudC5idXR0b24gIT09IDApIHJldHVybjsgLy8gQWxsb3cgb25seSBjaG9zZW4gcG9pbnRlciB0eXBlXG5cbiAgICBpZiAoYWxsb3dPbmx5UG9pbnRlclR5cGUgIT09ICdhbGwnICYmIGV2ZW50LnBvaW50ZXJUeXBlICE9PSBhbGxvd09ubHlQb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9uUG9pbnRlclVwKCk7XG4gIH07XG4gIC8qIE1vdXNlIEhhbmRsZXJzIGVuZHMgKi9cblxuXG4gIFJlYWN0X19uYW1lc3BhY2UudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwb3J0SW1hZ2U6IGZ1bmN0aW9uIGV4cG9ydEltYWdlKGltYWdlVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcywgX2dldENhbnZhc1dpdGhWaWV3Qm94LCBzdmdDYW52YXMsIF93aWR0aCwgX2hlaWdodCwgY2FudmFzU2tldGNoLCBsb2FkSW1hZ2VQcm9taXNlcywgaW1nO1xuXG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbnZhcyBub3QgcmVuZGVyZWQgeWV0Jyk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgX2dldENhbnZhc1dpdGhWaWV3Qm94ID0gZ2V0Q2FudmFzV2l0aFZpZXdCb3goY2FudmFzKSwgc3ZnQ2FudmFzID0gX2dldENhbnZhc1dpdGhWaWV3Qm94LnN2Z0NhbnZhcywgX3dpZHRoID0gX2dldENhbnZhc1dpdGhWaWV3Qm94LndpZHRoLCBfaGVpZ2h0ID0gX2dldENhbnZhc1dpdGhWaWV3Qm94LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzU2tldGNoID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiICsgYnRvYShzdmdDYW52YXMub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2FkSW1hZ2UoY2FudmFzU2tldGNoKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRJbWFnZVByb21pc2VzID0gW19jb250ZXh0LnQwXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cG9ydFdpdGhCYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRJbWFnZShiYWNrZ3JvdW5kSW1hZ2UpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBpbWcgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgICAgICBsb2FkSW1hZ2VQcm9taXNlcy5wdXNoKGltZyk7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxODtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDExKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdleHBvcnRXaXRoQmFja2dyb3VuZEltYWdlIHByb3BzIGlzIHNldCB3aXRob3V0IGEgdmFsaWQgYmFja2dyb3VuZCBpbWFnZSBVUkwuIFRoaXMgb3B0aW9uIGlzIGlnbm9yZWQnKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwobG9hZEltYWdlUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIF93aWR0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBfaGVpZ2h0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcmVuZGVyQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW52YXMgbm90IHJlbmRlcmVkIHlldCcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlcy5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlbmRlckNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9cIiArIGltYWdlVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNDtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDIgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoX2NvbnRleHQudDIpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCAyNF0sIFsxMSwgMThdXSk7XG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKSk7XG4gICAgICB9LFxuICAgICAgZXhwb3J0U3ZnOiBmdW5jdGlvbiBleHBvcnRTdmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfY2FudmFzUmVmJGN1cnJlbnQyO1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gKF9jYW52YXNSZWYkY3VycmVudDIgPSBjYW52YXNSZWYuY3VycmVudCkgIT0gbnVsbCA/IF9jYW52YXNSZWYkY3VycmVudDIgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoY2FudmFzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMsIF9zdmdDYW52YXMkcXVlcnlTZWxlYzI7XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRDYW52YXNXaXRoVmlld0JveDIgPSBnZXRDYW52YXNXaXRoVmlld0JveChjYW52YXMpLFxuICAgICAgICAgICAgICAgICAgc3ZnQ2FudmFzID0gX2dldENhbnZhc1dpdGhWaWV3Qm94Mi5zdmdDYW52YXM7XG5cbiAgICAgICAgICAgICAgaWYgKGV4cG9ydFdpdGhCYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHN2Z0NhbnZhcy5vdXRlckhUTUwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIChfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMgPSBzdmdDYW52YXMucXVlcnlTZWxlY3RvcihcIiNcIiArIGlkICsgXCJfX2JhY2tncm91bmRcIikpID09IG51bGwgPyB2b2lkIDAgOiBfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIChfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMyID0gc3ZnQ2FudmFzLnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBpZCArIFwiX19jYW52YXMtYmFja2dyb3VuZFwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdmdDYW52YXMkcXVlcnlTZWxlYzIuc2V0QXR0cmlidXRlKCdmaWxsJywgY2FudmFzQ29sb3IpO1xuICAgICAgICAgICAgICByZXNvbHZlKHN2Z0NhbnZhcy5vdXRlckhUTUwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDYW52YXMgbm90IGxvYWRlZCcpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgLyogQWRkIGV2ZW50IGxpc3RlbmVyIHRvIE1vdXNlIHVwIGFuZCBUb3VjaCB1cCB0b1xyXG4gIHJlbGVhc2UgZHJhd2luZyBldmVuIHdoZW4gcG9pbnQgZ29lcyBvdXQgb2YgY2FudmFzICovXG5cbiAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgfTtcbiAgfSwgW2hhbmRsZVBvaW50ZXJVcF0pO1xuICB2YXIgZXJhc2VyUGF0aHMgPSBwYXRocy5maWx0ZXIoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gIXBhdGguZHJhd01vZGU7XG4gIH0pO1xuICB2YXIgY3VycmVudEdyb3VwID0gMDtcbiAgdmFyIHBhdGhHcm91cHMgPSBwYXRocy5yZWR1Y2UoZnVuY3Rpb24gKGFycmF5R3JvdXAsIHBhdGgpIHtcbiAgICBpZiAoIXBhdGguZHJhd01vZGUpIHtcbiAgICAgIGN1cnJlbnRHcm91cCArPSAxO1xuICAgICAgcmV0dXJuIGFycmF5R3JvdXA7XG4gICAgfVxuXG4gICAgaWYgKGFycmF5R3JvdXBbY3VycmVudEdyb3VwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcnJheUdyb3VwW2N1cnJlbnRHcm91cF0gPSBbXTtcbiAgICB9XG5cbiAgICBhcnJheUdyb3VwW2N1cnJlbnRHcm91cF0ucHVzaChwYXRoKTtcbiAgICByZXR1cm4gYXJyYXlHcm91cDtcbiAgfSwgW1tdXSk7XG4gIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgcmVmOiBjYW52YXNSZWYsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0sIHN0eWxlKSxcbiAgICBcInRvdWNoLWFjdGlvblwiOiBcIm5vbmVcIixcbiAgICBvblBvaW50ZXJEb3duOiBoYW5kbGVQb2ludGVyRG93bixcbiAgICBvblBvaW50ZXJNb3ZlOiBoYW5kbGVQb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJVcDogaGFuZGxlUG9pbnRlclVwXG4gIH0sIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgdmVyc2lvbjogXCIxLjFcIixcbiAgICBiYXNlUHJvZmlsZTogXCJmdWxsXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB4bWxuc1hsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgfSwgc3ZnU3R5bGUpLFxuICAgIGlkOiBpZFxuICB9LCBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBpZDogaWQgKyBcIl9fZXJhc2VyLXN0cm9rZS1ncm91cFwiLFxuICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gIH0sIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIGlkOiBpZCArIFwiX19tYXNrLWJhY2tncm91bmRcIixcbiAgICB4OiBcIjBcIixcbiAgICB5OiBcIjBcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSksIGVyYXNlclBhdGhzLm1hcChmdW5jdGlvbiAoZXJhc2VyUGF0aCwgaSkge1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoU3ZnUGF0aCwge1xuICAgICAga2V5OiBpZCArIFwiX19lcmFzZXItXCIgKyBpLFxuICAgICAgaWQ6IGlkICsgXCJfX2VyYXNlci1cIiArIGksXG4gICAgICBwYXRoczogZXJhc2VyUGF0aC5wYXRocyxcbiAgICAgIHN0cm9rZUNvbG9yOiBcIiMwMDAwMDBcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBlcmFzZXJQYXRoLnN0cm9rZVdpZHRoXG4gICAgfSk7XG4gIH0pKSwgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCBiYWNrZ3JvdW5kSW1hZ2UgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0dGVyblwiLCB7XG4gICAgaWQ6IGlkICsgXCJfX2JhY2tncm91bmRcIixcbiAgICB4OiBcIjBcIixcbiAgICB5OiBcIjBcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBwYXR0ZXJuVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICB9LCBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiLCB7XG4gICAgeDogXCIwXCIsXG4gICAgeTogXCIwXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgeGxpbmtIcmVmOiBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogcHJlc2VydmVCYWNrZ3JvdW5kSW1hZ2VBc3BlY3RSYXRpb1xuICB9KSksIGVyYXNlclBhdGhzLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJtYXNrXCIsIHtcbiAgICAgIGlkOiBpZCArIFwiX19lcmFzZXItbWFzay1cIiArIGksXG4gICAgICBrZXk6IGlkICsgXCJfX2VyYXNlci1tYXNrLVwiICsgaSxcbiAgICAgIG1hc2tVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgfSwgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidXNlXCIsIHtcbiAgICAgIGhyZWY6IFwiI1wiICsgaWQgKyBcIl9fbWFzay1iYWNrZ3JvdW5kXCJcbiAgICB9KSwgQXJyYXkuZnJvbSh7XG4gICAgICBsZW5ndGg6IGVyYXNlclBhdGhzLmxlbmd0aCAtIGlcbiAgICB9LCBmdW5jdGlvbiAoXywgaikge1xuICAgICAgcmV0dXJuIGogKyBpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInVzZVwiLCB7XG4gICAgICAgIGtleTogay50b1N0cmluZygpLFxuICAgICAgICBocmVmOiBcIiNcIiArIGlkICsgXCJfX2VyYXNlci1cIiArIGsudG9TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9KSksIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGlkOiBpZCArIFwiX19jYW52YXMtYmFja2dyb3VuZC1ncm91cFwiXG4gIH0sIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIGlkOiBpZCArIFwiX19jYW52YXMtYmFja2dyb3VuZFwiLFxuICAgIHg6IFwiMFwiLFxuICAgIHk6IFwiMFwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIGZpbGw6IGJhY2tncm91bmRJbWFnZSA/IFwidXJsKCNcIiArIGlkICsgXCJfX2JhY2tncm91bmQpXCIgOiBjYW52YXNDb2xvclxuICB9KSksIHBhdGhHcm91cHMubWFwKGZ1bmN0aW9uIChwYXRoR3JvdXAsIGkpIHtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICBpZDogaWQgKyBcIl9fc3Ryb2tlLWdyb3VwLVwiICsgaSxcbiAgICAgIGtleTogaWQgKyBcIl9fc3Ryb2tlLWdyb3VwLVwiICsgaSxcbiAgICAgIG1hc2s6IFwidXJsKCNcIiArIGlkICsgXCJfX2VyYXNlci1tYXNrLVwiICsgaSArIFwiKVwiXG4gICAgfSwgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBhdGhzLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBwYXRoczogcGF0aEdyb3VwXG4gICAgfSkpO1xuICB9KSkpO1xufSk7XG5cbnZhciBSZWFjdFNrZXRjaENhbnZhcyA9IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIF9wcm9wcyRpZCA9IHByb3BzLmlkLFxuICAgICAgaWQgPSBfcHJvcHMkaWQgPT09IHZvaWQgMCA/ICdyZWFjdC1za2V0Y2gtY2FudmFzJyA6IF9wcm9wcyRpZCxcbiAgICAgIF9wcm9wcyR3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgICAgd2lkdGggPSBfcHJvcHMkd2lkdGggPT09IHZvaWQgMCA/ICcxMDAlJyA6IF9wcm9wcyR3aWR0aCxcbiAgICAgIF9wcm9wcyRoZWlnaHQgPSBwcm9wcy5oZWlnaHQsXG4gICAgICBoZWlnaHQgPSBfcHJvcHMkaGVpZ2h0ID09PSB2b2lkIDAgPyAnMTAwJScgOiBfcHJvcHMkaGVpZ2h0LFxuICAgICAgX3Byb3BzJGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9wcm9wcyRjbGFzc05hbWUgPT09IHZvaWQgMCA/ICcnIDogX3Byb3BzJGNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjYW52YXNDb2xvciA9IHByb3BzLmNhbnZhc0NvbG9yLFxuICAgICAgY2FudmFzQ29sb3IgPSBfcHJvcHMkY2FudmFzQ29sb3IgPT09IHZvaWQgMCA/ICd3aGl0ZScgOiBfcHJvcHMkY2FudmFzQ29sb3IsXG4gICAgICBfcHJvcHMkc3Ryb2tlQ29sb3IgPSBwcm9wcy5zdHJva2VDb2xvcixcbiAgICAgIHN0cm9rZUNvbG9yID0gX3Byb3BzJHN0cm9rZUNvbG9yID09PSB2b2lkIDAgPyAncmVkJyA6IF9wcm9wcyRzdHJva2VDb2xvcixcbiAgICAgIF9wcm9wcyRiYWNrZ3JvdW5kSW1hZyA9IHByb3BzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgIGJhY2tncm91bmRJbWFnZSA9IF9wcm9wcyRiYWNrZ3JvdW5kSW1hZyA9PT0gdm9pZCAwID8gJycgOiBfcHJvcHMkYmFja2dyb3VuZEltYWcsXG4gICAgICBfcHJvcHMkZXhwb3J0V2l0aEJhY2sgPSBwcm9wcy5leHBvcnRXaXRoQmFja2dyb3VuZEltYWdlLFxuICAgICAgZXhwb3J0V2l0aEJhY2tncm91bmRJbWFnZSA9IF9wcm9wcyRleHBvcnRXaXRoQmFjayA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZXhwb3J0V2l0aEJhY2ssXG4gICAgICBfcHJvcHMkcHJlc2VydmVCYWNrZ3IgPSBwcm9wcy5wcmVzZXJ2ZUJhY2tncm91bmRJbWFnZUFzcGVjdFJhdGlvLFxuICAgICAgcHJlc2VydmVCYWNrZ3JvdW5kSW1hZ2VBc3BlY3RSYXRpbyA9IF9wcm9wcyRwcmVzZXJ2ZUJhY2tnciA9PT0gdm9pZCAwID8gJ25vbmUnIDogX3Byb3BzJHByZXNlcnZlQmFja2dyLFxuICAgICAgX3Byb3BzJHN0cm9rZVdpZHRoID0gcHJvcHMuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9wcm9wcyRzdHJva2VXaWR0aCA9PT0gdm9pZCAwID8gNCA6IF9wcm9wcyRzdHJva2VXaWR0aCxcbiAgICAgIF9wcm9wcyRlcmFzZXJXaWR0aCA9IHByb3BzLmVyYXNlcldpZHRoLFxuICAgICAgZXJhc2VyV2lkdGggPSBfcHJvcHMkZXJhc2VyV2lkdGggPT09IHZvaWQgMCA/IDggOiBfcHJvcHMkZXJhc2VyV2lkdGgsXG4gICAgICBfcHJvcHMkYWxsb3dPbmx5UG9pbnQgPSBwcm9wcy5hbGxvd09ubHlQb2ludGVyVHlwZSxcbiAgICAgIGFsbG93T25seVBvaW50ZXJUeXBlID0gX3Byb3BzJGFsbG93T25seVBvaW50ID09PSB2b2lkIDAgPyAnYWxsJyA6IF9wcm9wcyRhbGxvd09ubHlQb2ludCxcbiAgICAgIF9wcm9wcyRzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgc3R5bGUgPSBfcHJvcHMkc3R5bGUgPT09IHZvaWQgMCA/IHtcbiAgICBib3JkZXI6ICcwLjA2MjVyZW0gc29saWQgIzljOWM5YycsXG4gICAgYm9yZGVyUmFkaXVzOiAnMC4yNXJlbSdcbiAgfSA6IF9wcm9wcyRzdHlsZSxcbiAgICAgIF9wcm9wcyRzdmdTdHlsZSA9IHByb3BzLnN2Z1N0eWxlLFxuICAgICAgc3ZnU3R5bGUgPSBfcHJvcHMkc3ZnU3R5bGUgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJHN2Z1N0eWxlLFxuICAgICAgX3Byb3BzJG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBvbkNoYW5nZSA9IF9wcm9wcyRvbkNoYW5nZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKF9wYXRocykge30gOiBfcHJvcHMkb25DaGFuZ2UsXG4gICAgICBfcHJvcHMkb25TdHJva2UgPSBwcm9wcy5vblN0cm9rZSxcbiAgICAgIG9uU3Ryb2tlID0gX3Byb3BzJG9uU3Ryb2tlID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoX3BhdGgsIF9pc0VyYXNlcikge30gOiBfcHJvcHMkb25TdHJva2UsXG4gICAgICBfcHJvcHMkd2l0aFRpbWVzdGFtcCA9IHByb3BzLndpdGhUaW1lc3RhbXAsXG4gICAgICB3aXRoVGltZXN0YW1wID0gX3Byb3BzJHdpdGhUaW1lc3RhbXAgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHdpdGhUaW1lc3RhbXA7XG4gIHZhciBzdmdDYW52YXMgPSBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZVJlZigpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHRydWUpLFxuICAgICAgZHJhd01vZGUgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXREcmF3TW9kZSA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgaXNEcmF3aW5nID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldElzRHJhd2luZyA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKFtdKSxcbiAgICAgIHJlc2V0U3RhY2sgPSBfUmVhY3QkdXNlU3RhdGUzWzBdLFxuICAgICAgc2V0UmVzZXRTdGFjayA9IF9SZWFjdCR1c2VTdGF0ZTNbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTQgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKFtdKSxcbiAgICAgIHVuZG9TdGFjayA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRVbmRvU3RhY2sgPSBfUmVhY3QkdXNlU3RhdGU0WzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGU1ID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShbXSksXG4gICAgICBjdXJyZW50UGF0aHMgPSBfUmVhY3QkdXNlU3RhdGU1WzBdLFxuICAgICAgc2V0Q3VycmVudFBhdGhzID0gX1JlYWN0JHVzZVN0YXRlNVsxXTtcblxuICB2YXIgbGlmdFN0cm9rZVVwID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9jdXJyZW50UGF0aHMkc2xpY2UkLCBfY3VycmVudFBhdGhzJHNsaWNlO1xuXG4gICAgdmFyIGxhc3RTdHJva2UgPSAoX2N1cnJlbnRQYXRocyRzbGljZSQgPSAoX2N1cnJlbnRQYXRocyRzbGljZSA9IGN1cnJlbnRQYXRocy5zbGljZSgtMSkpID09IG51bGwgPyB2b2lkIDAgOiBfY3VycmVudFBhdGhzJHNsaWNlWzBdKSAhPSBudWxsID8gX2N1cnJlbnRQYXRocyRzbGljZSQgOiBudWxsO1xuXG4gICAgaWYgKGxhc3RTdHJva2UgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gc3Ryb2tlIGZvdW5kIScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9uU3Ryb2tlKGxhc3RTdHJva2UsICFsYXN0U3Ryb2tlLmRyYXdNb2RlKTtcbiAgfSwgW2lzRHJhd2luZ10pO1xuICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgbGlmdFN0cm9rZVVwKCk7XG4gIH0sIFtpc0RyYXdpbmddKTtcbiAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIG9uQ2hhbmdlKGN1cnJlbnRQYXRocyk7XG4gIH0sIFtjdXJyZW50UGF0aHNdKTtcbiAgUmVhY3RfX25hbWVzcGFjZS51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlcmFzZU1vZGU6IGZ1bmN0aW9uIGVyYXNlTW9kZShlcmFzZSkge1xuICAgICAgICBzZXREcmF3TW9kZSghZXJhc2UpO1xuICAgICAgfSxcbiAgICAgIGNsZWFyQ2FudmFzOiBmdW5jdGlvbiBjbGVhckNhbnZhcygpIHtcbiAgICAgICAgc2V0UmVzZXRTdGFjayhbXS5jb25jYXQoY3VycmVudFBhdGhzKSk7XG4gICAgICAgIHNldEN1cnJlbnRQYXRocyhbXSk7XG4gICAgICB9LFxuICAgICAgdW5kbzogZnVuY3Rpb24gdW5kbygpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgbGFzdCByZXNldCB0aGVuXG4gICAgICAgIGlmIChyZXNldFN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHNldEN1cnJlbnRQYXRocyhbXS5jb25jYXQocmVzZXRTdGFjaykpO1xuICAgICAgICAgIHNldFJlc2V0U3RhY2soW10pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFVuZG9TdGFjayhmdW5jdGlvbiAodW5kb1N0YWNrKSB7XG4gICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCh1bmRvU3RhY2ssIGN1cnJlbnRQYXRocy5zbGljZSgtMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0Q3VycmVudFBhdGhzKGZ1bmN0aW9uIChjdXJyZW50UGF0aHMpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudFBhdGhzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVkbzogZnVuY3Rpb24gcmVkbygpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBSZWRvXG4gICAgICAgIGlmICh1bmRvU3RhY2subGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHNldEN1cnJlbnRQYXRocyhmdW5jdGlvbiAoY3VycmVudFBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChjdXJyZW50UGF0aHMsIHVuZG9TdGFjay5zbGljZSgtMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0VW5kb1N0YWNrKGZ1bmN0aW9uICh1bmRvU3RhY2spIHtcbiAgICAgICAgICByZXR1cm4gdW5kb1N0YWNrLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXhwb3J0SW1hZ2U6IGZ1bmN0aW9uIGV4cG9ydEltYWdlKGltYWdlVHlwZSkge1xuICAgICAgICB2YXIgX3N2Z0NhbnZhcyRjdXJyZW50O1xuXG4gICAgICAgIHZhciBleHBvcnRJbWFnZSA9IChfc3ZnQ2FudmFzJGN1cnJlbnQgPSBzdmdDYW52YXMuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdmdDYW52YXMkY3VycmVudC5leHBvcnRJbWFnZTtcblxuICAgICAgICBpZiAoIWV4cG9ydEltYWdlKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0V4cG9ydCBmdW5jdGlvbiBjYWxsZWQgYmVmb3JlIGNhbnZhcyBsb2FkZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0SW1hZ2UoaW1hZ2VUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4cG9ydFN2ZzogZnVuY3Rpb24gZXhwb3J0U3ZnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBfc3ZnQ2FudmFzJGN1cnJlbnQyO1xuXG4gICAgICAgICAgdmFyIGV4cG9ydFN2ZyA9IChfc3ZnQ2FudmFzJGN1cnJlbnQyID0gc3ZnQ2FudmFzLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfc3ZnQ2FudmFzJGN1cnJlbnQyLmV4cG9ydFN2ZztcblxuICAgICAgICAgIGlmICghZXhwb3J0U3ZnKSB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ0V4cG9ydCBmdW5jdGlvbiBjYWxsZWQgYmVmb3JlIGNhbnZhcyBsb2FkZWQnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydFN2ZygpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBleHBvcnRQYXRoczogZnVuY3Rpb24gZXhwb3J0UGF0aHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmUoY3VycmVudFBhdGhzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsb2FkUGF0aHM6IGZ1bmN0aW9uIGxvYWRQYXRocyhwYXRocykge1xuICAgICAgICBzZXRDdXJyZW50UGF0aHMoZnVuY3Rpb24gKGN1cnJlbnRQYXRocykge1xuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoY3VycmVudFBhdGhzLCBwYXRocyk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldFNrZXRjaGluZ1RpbWU6IGZ1bmN0aW9uIGdldFNrZXRjaGluZ1RpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaWYgKCF3aXRoVGltZXN0YW1wKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiU2V0ICd3aXRoVGltZXN0YW1wJyBwcm9wIHRvIGdldCBza2V0Y2hpbmcgdGltZVwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBza2V0Y2hpbmdUaW1lID0gY3VycmVudFBhdGhzLnJlZHVjZShmdW5jdGlvbiAodG90YWxTa2V0Y2hpbmdUaW1lLCBwYXRoKSB7XG4gICAgICAgICAgICAgIHZhciBfcGF0aCRzdGFydFRpbWVzdGFtcCwgX3BhdGgkZW5kVGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgIHZhciBzdGFydFRpbWVzdGFtcCA9IChfcGF0aCRzdGFydFRpbWVzdGFtcCA9IHBhdGguc3RhcnRUaW1lc3RhbXApICE9IG51bGwgPyBfcGF0aCRzdGFydFRpbWVzdGFtcCA6IDA7XG4gICAgICAgICAgICAgIHZhciBlbmRUaW1lc3RhbXAgPSAoX3BhdGgkZW5kVGltZXN0YW1wID0gcGF0aC5lbmRUaW1lc3RhbXApICE9IG51bGwgPyBfcGF0aCRlbmRUaW1lc3RhbXAgOiAwO1xuICAgICAgICAgICAgICByZXR1cm4gdG90YWxTa2V0Y2hpbmdUaW1lICsgKGVuZFRpbWVzdGFtcCAtIHN0YXJ0VGltZXN0YW1wKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmVzb2x2ZShza2V0Y2hpbmdUaW1lKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZXNldENhbnZhczogZnVuY3Rpb24gcmVzZXRDYW52YXMoKSB7XG4gICAgICAgIHNldFJlc2V0U3RhY2soW10pO1xuICAgICAgICBzZXRVbmRvU3RhY2soW10pO1xuICAgICAgICBzZXRDdXJyZW50UGF0aHMoW10pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIHZhciBoYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKHBvaW50KSB7XG4gICAgc2V0SXNEcmF3aW5nKHRydWUpO1xuICAgIHNldFVuZG9TdGFjayhbXSk7XG4gICAgdmFyIHN0cm9rZSA9IHtcbiAgICAgIGRyYXdNb2RlOiBkcmF3TW9kZSxcbiAgICAgIHN0cm9rZUNvbG9yOiBkcmF3TW9kZSA/IHN0cm9rZUNvbG9yIDogJyMwMDAwMDAnLFxuICAgICAgc3Ryb2tlV2lkdGg6IGRyYXdNb2RlID8gc3Ryb2tlV2lkdGggOiBlcmFzZXJXaWR0aCxcbiAgICAgIHBhdGhzOiBbcG9pbnRdXG4gICAgfTtcblxuICAgIGlmICh3aXRoVGltZXN0YW1wKSB7XG4gICAgICBzdHJva2UgPSBfZXh0ZW5kcyh7fSwgc3Ryb2tlLCB7XG4gICAgICAgIHN0YXJ0VGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBlbmRUaW1lc3RhbXA6IDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRQYXRocyhmdW5jdGlvbiAoY3VycmVudFBhdGhzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KGN1cnJlbnRQYXRocywgW3N0cm9rZV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb2ludGVyTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlKHBvaW50KSB7XG4gICAgaWYgKCFpc0RyYXdpbmcpIHJldHVybjtcbiAgICB2YXIgY3VycmVudFN0cm9rZSA9IGN1cnJlbnRQYXRocy5zbGljZSgtMSlbMF07XG5cbiAgICB2YXIgdXBkYXRlZFN0cm9rZSA9IF9leHRlbmRzKHt9LCBjdXJyZW50U3Ryb2tlLCB7XG4gICAgICBwYXRoczogW10uY29uY2F0KGN1cnJlbnRTdHJva2UucGF0aHMsIFtwb2ludF0pXG4gICAgfSk7XG5cbiAgICBzZXRDdXJyZW50UGF0aHMoZnVuY3Rpb24gKGN1cnJlbnRQYXRocykge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChjdXJyZW50UGF0aHMuc2xpY2UoMCwgLTEpLCBbdXBkYXRlZFN0cm9rZV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyVXAoKSB7XG4gICAgdmFyIF9jdXJyZW50UGF0aHMkc2xpY2UkMiwgX2N1cnJlbnRQYXRocyRzbGljZTI7XG5cbiAgICBpZiAoIWlzRHJhd2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldElzRHJhd2luZyhmYWxzZSk7XG5cbiAgICBpZiAoIXdpdGhUaW1lc3RhbXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFN0cm9rZSA9IChfY3VycmVudFBhdGhzJHNsaWNlJDIgPSAoX2N1cnJlbnRQYXRocyRzbGljZTIgPSBjdXJyZW50UGF0aHMuc2xpY2UoLTEpKSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRQYXRocyRzbGljZTJbMF0pICE9IG51bGwgPyBfY3VycmVudFBhdGhzJHNsaWNlJDIgOiBudWxsO1xuXG4gICAgaWYgKGN1cnJlbnRTdHJva2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlZFN0cm9rZSA9IF9leHRlbmRzKHt9LCBjdXJyZW50U3Ryb2tlLCB7XG4gICAgICBlbmRUaW1lc3RhbXA6IERhdGUubm93KClcbiAgICB9KTtcblxuICAgIHNldEN1cnJlbnRQYXRocyhmdW5jdGlvbiAoY3VycmVudFBhdGhzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KGN1cnJlbnRQYXRocy5zbGljZSgwLCAtMSksIFt1cGRhdGVkU3Ryb2tlXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDYW52YXMsIHtcbiAgICByZWY6IHN2Z0NhbnZhcyxcbiAgICBpZDogaWQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGNhbnZhc0NvbG9yOiBjYW52YXNDb2xvcixcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGJhY2tncm91bmRJbWFnZSxcbiAgICBleHBvcnRXaXRoQmFja2dyb3VuZEltYWdlOiBleHBvcnRXaXRoQmFja2dyb3VuZEltYWdlLFxuICAgIHByZXNlcnZlQmFja2dyb3VuZEltYWdlQXNwZWN0UmF0aW86IHByZXNlcnZlQmFja2dyb3VuZEltYWdlQXNwZWN0UmF0aW8sXG4gICAgYWxsb3dPbmx5UG9pbnRlclR5cGU6IGFsbG93T25seVBvaW50ZXJUeXBlLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBzdmdTdHlsZTogc3ZnU3R5bGUsXG4gICAgcGF0aHM6IGN1cnJlbnRQYXRocyxcbiAgICBpc0RyYXdpbmc6IGlzRHJhd2luZyxcbiAgICBvblBvaW50ZXJEb3duOiBoYW5kbGVQb2ludGVyRG93bixcbiAgICBvblBvaW50ZXJNb3ZlOiBoYW5kbGVQb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJVcDogaGFuZGxlUG9pbnRlclVwXG4gIH0pO1xufSk7XG5cbmV4cG9ydHMuQ2FudmFzID0gQ2FudmFzO1xuZXhwb3J0cy5SZWFjdFNrZXRjaENhbnZhcyA9IFJlYWN0U2tldGNoQ2FudmFzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtc2tldGNoLWNhbnZhcy5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-sketch-canvas/dist/react-sketch-canvas.cjs.development.js\n");

/***/ })

};
;